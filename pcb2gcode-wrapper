#!/usr/bin/env ruby
# frozen_string_literal: true

# Define constants
MILLREADY_CMD = 'pcb2gcode-millready'
COMBINE_CMD = 'pcb2gcode-combine'
# Default margins: additional space added to board dimensions for offset calculations
#
# X-offset calculation: depends on board width
#   Formula: x-offset = -1 * (ceil(width_in_mm) + x_margin)
#   The negative sign moves the PCB to the right of the origin.
#   This is calculated from the edge cuts file to position the board correctly.
#
# Y-offset calculation: fixed margin value (not based on board height)
#   Formula: y-offset = y_margin
#   This is a simple offset for clearance/tooling, not calculated from dimensions.
DEFAULT_X_MARGIN = 5
DEFAULT_Y_MARGIN = 3

# Display help message
# rubocop:disable Metrics/MethodLength, Metrics/AbcSize
def show_help
  puts 'Usage: pcb2gcode-wrapper BASENAME [options]'
  puts ''
  puts 'DESCRIPTION:'
  puts '  Wrapper script that runs pcb2gcode three times with the specified basename:'
  puts '  1. For back copper, --back on [basename]-B_Cu.gbr'
  puts '  2. For drill holes, --drill on [basename]-PTH.drl'
  puts '  3. For board outline, --outline on [basename]-Edge_Cuts.gbr'
  puts ''
  puts 'OPTIONS:'
  puts '  -h, --help                 Show this help message and exit'
  puts "  --x-margin VALUE           X margin (in mm) used for x-offset calculation (default: #{DEFAULT_X_MARGIN})"
  puts "  --y-margin VALUE           Y margin (in mm) used for y-offset (default: #{DEFAULT_Y_MARGIN})"
  puts '  --no-combine               Skip combining drill/milldrill/outline into single file'
  puts '  Any other options will be passed to all three pcb2gcode commands'
  puts '  The --x-offset parameter will be automatically calculated from edge cuts if present'
  puts "  The --y-offset parameter defaults to #{DEFAULT_Y_MARGIN}mm if not specified"
  puts ''
  puts 'EXAMPLES:'
  puts '  pcb2gcode-wrapper myboard'
  puts '  pcb2gcode-wrapper myboard --output-dir ./output'
  puts '  pcb2gcode-wrapper myboard --x-margin 10 --y-margin 7'
  puts '  pcb2gcode-wrapper myboard --x-offset=-10 --y-offset=5'
end
# rubocop:enable Metrics/MethodLength, Metrics/AbcSize

# Check for help flag
if ARGV.include?('--help') || ARGV.include?('-h')
  show_help
  exit 0
end

# Ensure we have at least the basename
if ARGV.empty?
  puts 'Error: BASENAME is required'
  puts ''
  show_help
  exit 1
end

# Get the basename and the rest of the arguments
basename = ARGV.shift
other_args = ARGV.join(' ')

# Extract margin from arguments
def extract_margin(other_args, margin_name, default_value)
  margin = default_value
  pattern = /--#{margin_name}-margin(?:=|\s+)(\S+)/
  if other_args =~ pattern
    margin_raw = Regexp.last_match(1)
    margin = margin_raw.to_f
    if margin <= 0
      puts "Error: #{margin_name.upcase} margin must be a positive number, got: #{margin_raw}"
      exit 1
    end
    puts "#{margin_name.upcase} margin set to: #{margin}mm"
    # Remove --#{margin_name}-margin from other_args so it doesn't get passed to pcb2gcode
    other_args = other_args.sub(pattern, '').gsub(/\s+/, ' ').strip
  end
  [margin, other_args]
end

x_margin, other_args = extract_margin(other_args, 'x', DEFAULT_X_MARGIN)
y_margin, other_args = extract_margin(other_args, 'y', DEFAULT_Y_MARGIN)

# Check for --no-combine flag
skip_combine = other_args.include?('--no-combine')
other_args = other_args.sub('--no-combine', '').gsub(/\s+/, ' ').strip if skip_combine

# Extract the output directory if specified
output_dir = ''
# Match both --output-dir value and --output-dir=value formats
# Pattern matches: --output-dir=value or --output-dir value
if other_args =~ /--output-dir(?:=|\s+)(\S+)/
  output_dir_raw = Regexp.last_match(1)
  # Expand ~ to home directory and ensure trailing slash
  output_dir_expanded = File.expand_path(output_dir_raw).chomp('/')
  output_dir = "#{output_dir_expanded}/"
  puts "Output directory detected: #{output_dir}"
  # Replace the original --output-dir value in other_args with expanded path
  # This ensures pcb2gcode gets the expanded path (it may not expand ~ itself)
  other_args = other_args.sub(/--output-dir(?:=|\s+)\S+/, "--output-dir=#{output_dir_expanded}")
end

# Ensure the output directory exists; exit with error if it doesn't exist
unless output_dir.empty? || Dir.exist?(output_dir)
  puts "Error: Output directory '#{output_dir}' does not exist."
  exit 1
end

# Parse FSLAX format specification
def parse_fslax_format(line)
  return nil unless line =~ /%FSLAX(\d)(\d)Y(\d)(\d)\*%/

  x_integer = Regexp.last_match(1).to_i
  x_decimal = Regexp.last_match(2).to_i
  units_factor = 10.0**x_decimal
  puts "Detected Gerber format: #{x_integer}.#{x_decimal}, units factor: #{units_factor}"
  units_factor
end

# Handle millimeter units detection
def handle_millimeter_units
  puts 'Detected millimeter units in Gerber file'
  [1_000_000.0, true]
end

# Parse units specification from Gerber header line
def parse_gerber_units(line, units_factor, millimeter_units)
  case line
  when /%FSLAX(\d)(\d)Y(\d)(\d)\*%/
    units_factor = parse_fslax_format(line) || units_factor
  when /%MOMM\*%/
    units_factor, millimeter_units = handle_millimeter_units
  when /%MOIN\*%/
    puts 'Detected inch units in Gerber file'
  end
  [units_factor, millimeter_units]
end

# Extract coordinates from Gerber line and update bounds
def update_coordinate_bounds(line, xmin, xmax, ymin, ymax)
  return [xmin, xmax, ymin, ymax] unless line =~ /^X([\d-]+)Y([\d-]+)/

  x = Regexp.last_match(1).to_i
  y = Regexp.last_match(2).to_i

  xmin = xmin ? [xmin, x].min : x
  xmax = xmax ? [xmax, x].max : x
  ymin = ymin ? [ymin, y].min : y
  ymax = ymax ? [ymax, y].max : y
  [xmin, xmax, ymin, ymax]
end

# Convert millimeter coordinates to inches
def convert_millimeters_to_inches(width, height, units_factor)
  width_mm = width / units_factor
  height_mm = height / units_factor
  puts "Board dimensions in mm: #{width_mm.round(2)}mm x #{height_mm.round(2)}mm"
  [width_mm / 25.4, height_mm / 25.4]
end

# Convert dimensions to inches based on detected format
def convert_to_inches(width, height, units_factor, millimeter_units)
  if millimeter_units
    convert_millimeters_to_inches(width, height, units_factor)
  else
    [width / units_factor, height / units_factor]
  end
end

# Calculate and display board dimensions
def display_board_dimensions(width_inches, height_inches)
  width_mm_display = (width_inches * 25.4).round(2)
  height_mm_display = (height_inches * 25.4).round(2)
  puts "Board dimensions detected: #{width_inches.round(4)}\" x #{height_inches.round(4)}\" " \
       "(#{width_mm_display}mm x #{height_mm_display}mm)"
end

# Calculate offset from dimension and margin
def calculate_offset(dimension_inches, margin, axis_name, dimension_name, negative: false)
  dimension_mm = dimension_inches * 25.4
  offset = negative ? -1 * (dimension_mm.ceil + margin) : (dimension_mm.ceil + margin)
  puts "Calculated #{axis_name}-offset: #{offset} " \
       "(based on #{dimension_name}: #{dimension_mm.round(2)}mm + #{margin}mm #{axis_name}-margin)"
  offset
end

# Extract coordinates from Gerber file
def extract_coordinates(filename)
  xmin = xmax = ymin = ymax = nil
  units_factor = 10_000.0 # Default: decimills to inches
  millimeter_units = false

  File.open(filename, 'r') do |file|
    file.each_line do |line|
      units_factor, millimeter_units = parse_gerber_units(line, units_factor, millimeter_units)
      xmin, xmax, ymin, ymax = update_coordinate_bounds(line, xmin, xmax, ymin, ymax)
    end
  end
  [xmin, xmax, ymin, ymax, units_factor, millimeter_units]
end

# Function to parse Gerber file and extract board dimensions
def parse_gerber_dimensions(filename, x_margin)
  return nil unless File.exist?(filename)

  xmin, xmax, ymin, ymax, units_factor, millimeter_units = extract_coordinates(filename)
  return nil if xmin.nil? || xmax.nil?

  width = xmax - xmin
  height = ymax - ymin
  width_inches, height_inches = convert_to_inches(width, height, units_factor, millimeter_units)
  display_board_dimensions(width_inches, height_inches)
  calculate_offset(width_inches, x_margin, 'x', 'width', negative: true)
end

# Check for edge cuts file and calculate x-offset
# Note: x-offset is calculated from board width (width + x_margin), unlike y-offset
edge_cuts_file = "#{basename}-Edge_Cuts.gbr"
x_offset = parse_gerber_dimensions(edge_cuts_file, x_margin)

# Add offset to other_args if calculated and not already present
def add_offset_to_args(other_args, offset, axis_name)
  offset_flag = "--#{axis_name}-offset"
  if offset && !other_args.include?(offset_flag)
    other_args += " #{offset_flag}=#{offset}"
    puts "Automatically added #{offset_flag}=#{offset} to commands"
  elsif other_args.include?(offset_flag)
    puts "#{axis_name}-offset parameter already specified in arguments, skipping auto-calculation"
  end
  other_args
end

# Add x-offset if calculated
if x_offset
  other_args = add_offset_to_args(other_args, x_offset, 'x')
elsif !File.exist?(edge_cuts_file)
  puts "Warning: #{edge_cuts_file} not found, cannot auto-calculate x-offset"
end

# Add y-offset (just the margin value, not calculated from board height)
# Note: y-offset is a fixed value (y_margin), unlike x-offset which is calculated from width
other_args = add_offset_to_args(other_args, y_margin, 'y') unless other_args.include?('--y-offset')

# Function to check if a command is available in PATH and executable
def command_available?(cmd)
  system("which #{cmd} > /dev/null 2>&1")
end

# Check if pcb2gcode-millready is available
millready_available = command_available?(MILLREADY_CMD)
puts "#{MILLREADY_CMD} #{millready_available ? 'found' : 'not found'} in PATH"

# Check if pcb2gcode-combine is available
combine_available = command_available?(COMBINE_CMD)
puts "#{COMBINE_CMD} #{combine_available ? 'found' : 'not found'} in PATH"

# Function to run a command and handle errors
def run_command(cmd)
  puts "Running: #{cmd}"
  result = system(cmd)
  return if result

  puts "Error executing command: #{cmd}"
  exit 1
end

# Function to run pcb2gcode-millready on an NGC file if available
# rubocop:disable Metrics/MethodLength
def run_millready(input_file, output_dir, millready_available)
  return unless millready_available

  # Prepend output directory if specified
  full_input_path = output_dir + input_file

  # Check if file exists in output directory, fallback to current directory
  if File.exist?(full_input_path)
    output_file = full_input_path.sub('.ngc', '-millready.ngc')
  elsif File.exist?(input_file)
    puts "Debug: Found #{input_file} in current directory (output-dir may not be working)"
    full_input_path = input_file
    output_file = input_file.sub('.ngc', '-millready.ngc')
  else
    puts "Warning: #{input_file} not found in #{output_dir.empty? ? 'current directory' : output_dir}"
    return
  end

  cmd = "#{MILLREADY_CMD} --remove-m6 #{full_input_path} #{output_file}"
  puts "Running: #{cmd}"
  result = system(cmd)
  puts "Warning: #{MILLREADY_CMD} failed on #{full_input_path}" unless result
end
# rubocop:enable Metrics/MethodLength

# Run the back copper command
back_cmd = "pcb2gcode --back #{basename}-B_Cu.gbr --basename #{basename} #{other_args}"
puts "\nProcessing back copper..."
run_command(back_cmd)
run_millready("#{basename}_back.ngc", output_dir, millready_available)

# Run the drill command
drill_cmd = "pcb2gcode --drill #{basename}-PTH.drl --drill-side back --basename #{basename} #{other_args}"
puts "\nProcessing drill holes..."
run_command(drill_cmd)
run_millready("#{basename}_drill.ngc", output_dir, millready_available)
run_millready("#{basename}_milldrill.ngc", output_dir, millready_available)

# Run the outline command
outline_cmd = "pcb2gcode --outline #{basename}-Edge_Cuts.gbr --cut-side back --basename #{basename} #{other_args}"
puts "\nProcessing board outline..."
run_command(outline_cmd)
run_millready("#{basename}_outline.ngc", output_dir, millready_available)

# Combine drill, milldrill, and outline into a single file
unless skip_combine
  if combine_available
    drill_file = "#{output_dir}#{basename}_drill-millready.ngc"
    milldrill_file = "#{output_dir}#{basename}_milldrill-millready.ngc"
    outline_file = "#{output_dir}#{basename}_outline-millready.ngc"
    combined_file = "#{output_dir}#{basename}_01_combined.ngc"

    # Check which files exist
    input_files = [drill_file, milldrill_file, outline_file].select { |f| File.exist?(f) }

    if input_files.length >= 2
      puts "\nCombining drill operations..."
      cmd = "#{COMBINE_CMD} #{input_files.join(' ')} -o #{combined_file}"
      puts "Running: #{cmd}"
      if system(cmd)
        puts "Created combined file: #{combined_file}"

        # Rename back file to sort first
        back_file = "#{output_dir}#{basename}_back-millready.ngc"
        back_file_renamed = "#{output_dir}#{basename}_00_back.ngc"
        if File.exist?(back_file)
          File.rename(back_file, back_file_renamed)
          puts "Renamed: #{back_file} -> #{back_file_renamed}"
        end
      else
        puts "Warning: #{COMBINE_CMD} failed"
      end
    else
      puts "Warning: Need at least 2 files to combine, found #{input_files.length}"
    end
  else
    puts "\nSkipping combine: #{COMBINE_CMD} not found in PATH"
  end
end

puts "\nAll operations completed successfully!"
